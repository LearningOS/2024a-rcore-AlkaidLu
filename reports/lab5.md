# 代码功能



# 问答题

**1. **

1. 需要回收的资源有哪些？

* **线程相关资源** ：
  * 线程栈 ，任务控制块 (`TaskControlBlock`) ，线程相关的信号量或锁的资源
* **共享资源** ：
  * 内核数据结构 ，文件描述符
* **线程独占资源** ：
  * 线程持有的动态分配内存， 线程相关的 IPC 资源

2. 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

* **调度队列**：
  * **位置**：在调度器的就绪队列或等待队列中。
  * **是否需要回收**：需要回收，因为这些 `TaskControlBlock` 对应的线程不再活动，应从调度器中移除。

* **锁或信号量的等待队列**：
  * **位置**：在 `Mutex` 或信号量的等待队列中。
  * **是否需要回收**：需要回收，否则这些引用会造成资源泄漏。需要在锁释放时检查是否有等待的线程，及时清理。

* **运行中的上下文**：
  * **位置**：当前正在 CPU 上运行的线程。
  * **是否需要回收**：需要回收。对于当前正在运行的线程，必须确保它的 `TaskControlBlock` 被标记为终止状态，切换调度到其他线程后再销毁资源。

**2.**

区别：

1. 解锁时机：
   - `Mutex1` 在所有情况下都在第 5 行设置 `mutex_inner.locked = false`。
   - `Mutex2` 仅在等待队列为空时，在第 19 行设置 `mutex_inner.locked = false`，否则通过唤醒任务隐式完成解锁。
2. 行为逻辑：
   - `Mutex1` 无论是否有任务等待锁，都会先将锁状态置为未锁定。
   - `Mutex2` 优化了逻辑，仅在没有任务需要唤醒时显式解锁，这样可以避免不必要的解锁操作。

可能的问题：

1. `Mutex1` 的问题：
   - 可能会在解锁后的一瞬间，导致其他线程误以为锁可用，试图竞争该锁，而实际任务尚未被唤醒。会导致竞态条件或资源分配异常。
2. `Mutex2` 的问题：
   - 如果解锁时没有检查 `locked` 状态，而直接唤醒任务，可能会在等待队列为空的情况下出现锁状态混乱。




# **荣誉准则**

**警告**

**请把填写了《你的说明》的下述内容拷贝到的到实验报告中。 否则，你的提交将视作无效，本次实验的成绩将按“0”分计。**

1. **在完成本次实验的过程（含此前学习的过程）中，我曾分别与 ****以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > *《你交流的对象说明》*
   >
2. **此外，我也参考了 ****以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > *《你参考的资料说明》*
   >
3. **我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。**
4. **我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。**
